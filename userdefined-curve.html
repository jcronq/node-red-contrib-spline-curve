<script type="text/javascript">
    RED.nodes.registerType('userdefined-curve',{
        category: 'function',
        color: '#a6bbcf',
        defaults: {
            name: {value:""},
            points: {
                value: [
                    {x: 0.0, y: 0.5},
                    {x: 1.0, y: 0.5}
                ]
            }
        },
        inputs:1,
        outputs:1,
        icon: "file.png",
        label: function() {
            return this.name||"interpolated-curve";
        },
        oneditprepare: function() {
        function Curve(config){
            'use strict';

            this.uid_seed       = 0;
            this.points 		= [];
            this.onAddPoint		= config.onAddPoint || function(index, point){};
            this.onMovePoint    = config.onMovePoint || function(index, point){};
            this.onRemovePoint  = config.onRemovePoint || function(index, point){};

            this.pointMap = {};
            
            this.addPoint = function(point){
                point.uid = this.uid_seed;
                this.uid_seed += 1;
                var insertIndex = 0;
                if(this.points.length == 0 || point.x > this.points[this.points.length-1].x){
                    this.points.push(point);
                }
                else if(point.x < this.points[0].x){
                    this.points.splice(0,0,point);
                }
                else{
                    for (insertIndex=0; insertIndex<this.points.length -1; insertIndex++){
                        if(this.points[insertIndex].x < point.x && this.points[insertIndex+1].x > point.x){
                            this.points.splice(insertIndex+1, 0, point);
                            break;
                        }
                    }
                }
                point.index = insertIndex;
                this.pointMap[point.uid] = point;
                this.onAddPoint(insertIndex, point);
            }

            this.removePoint = function(pointIndex){
                const point = this.points[pointIndex];
                this.points.splice(pointIndex, 1);
                this.onRemovePoint(pointIndex, point, this.pointMap[point.uid]);
                delete this.pointMap[point.uid];
            }

            this.movePoint = function(pointIndex, newValue){
                this.points[pointIndex].x = newValue.x;
                this.points[pointIndex].y = newValue.y;
                newValue.index = pointIndex;
                newValue.uid = this.points[pointIndex].uid;
                this.onMovePoint(pointIndex, newValue);
            }

            this.getPositionOfPoint = function(uid){
                for(var i=0; i < this.points.length; i++){
                    if(this.points[i].uid == uid)
                        return i;
                }
                return -1;
            };

            // Compare 2 points
            this.isEqual = function(p1,p2){
                return(p1.x == p2.x && p1.y == p2.y);
           }

            this.getClosestPointToCoordinate = function(coordinate, threshold=0.1){
                var pointerX = coordinate.x;
                var pointerY = coordinate.y;

                var dis = 10000;
                var clickedPoint = -1;

                for (var i=0;i<this.points.length;i++)
                {
                    var x1 = pointerX-this.points[i].x;
                    var y1 = pointerY-this.points[i].y;

                    var tdis = Math.sqrt(x1*x1+y1*y1);
                    if (tdis < dis && tdis < threshold) { 
                        dis = tdis;
                        clickedPoint = i;
                    }
                }	
                return clickedPoint;
            }

            this.linearValueAt = function(xpos){
                const p1 = this.points[0];
                const p2 = this.points[1];
                // y = mx+b
                const m = (p2.y-p1.y) / (p2.x-p1.x);
                const b = p1.y - (m * p1.x);
                return m * xpos + b;
            }

            this.getPolynomialInterpolationFunction = function (points) {
                var n = points.length - 1, p;

                p = function (i, j, x) {
                    if (i === j) {
                        return points[i].y;
                    }
            
                    return ((points[j].x - x) * p(i, j - 1, x) +
                        (x - points[i].x) * p(i + 1, j, x)) /
                        (points[j].x - points[i].x);
                };

                return function (x) {
                    if (points.length === 0) {
                        return 0;
                    }
                    return p(0, n, x);
                };
            }

            this.getValueAt = function(xpos) {
                'use strict';
            
                var retVal = 0;

                if(this.points.length <= 0)
                    retVal = 0;
                else if(this.points.length == 1)
                    retVal = this.points[0].y;
                else{
                    if(xpos <= this.points[0].x)
                        retVal = this.points[0].y;
                    else if(xpos >= this.points[this.points.length-1].x)
                        retVal = this.points[this.points.length-1].y;
                    else{
                        if(this.points.length == 2)
                            retVal = this.linearValueAt(xpos);
                        else{
                            const polyInterp = this.getPolynomialInterpolationFunction(this.points);
                            retVal = polyInterp(xpos);
                        } 
                    }
                }

                if (retVal < 0.0) return 0.0;
                if (retVal > 1.0) return 1.0;

                return retVal;
            }
           print 
            if (config.points){
                for (var i=0; i < config.points.length; i++ )
                    this.addPoint(config.points[i]);
            }
        }

        function CurveView(canvas, curve){
            'use strict';

            this.currentPoint = -1;
            this.curve          = curve;
            this.c 				= canvas;
            this.ctx 			= this.c.getContext('2d');
            this.height 		= this.c.height;
            this.width 			= this.c.width;
            this.redraw			= 0;
            this.onChange		= config.callback;

            this.point_selection_threshold = config.point_select_threshold || 0.1;

            if (this.height != this.width) {
                console.error("ERROR: Canvas must have same width and height.");
                return undefined;
            }

            var me = this;

            this.c.addEventListener('mousedown', function(ev) {
                me.mouseDown(ev);
            }, false);

            this.c.addEventListener('contextmenu', function(ev){
                me.rightClick(ev);
            }, false);

            this.c.addEventListener('mouseup',  function(ev) {
                me.mouseUp(ev);
                me.draw();
            }, false);
            
            this.c.addEventListener('mousemove',  function(ev) {
                me.mouseMove(ev);
                if (me.redraw == 1) {
                    me.draw();
                    me.redraw = 0;
                }
            }, false);

            // Compare 2 points
            this.isEqual = function(p1,p2)
            {
                'use strict';

                if (p1.x == p2.x && p1.y == p2.y) {
                    return true;
                } else {
                    return false;
                }
            }

            // Draw the curve
            this.draw = function() {
                'use strict';

                const points = this.curve.points;
                var p1,p4;

                this.ctx.clearRect(0, 0, this.width, this.height);
                this.drawGrid();

                if(points.length == 1){
                    this.ctx.beginPath();
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.moveTo(0, (1.0-this.curve.points[0].y) * this.height);
                    this.ctx.lineTo(this.width, (1.0-this.curve.points[0].y) * this.height);
                    this.ctx.stroke();
                }
                else{
                    for(var i=0;i<this.curve.points.length-1;i++)
                    {
                        if (i<1) {
                            p1 = points[0];
                        } else {
                            p1 = points[i-1];
                        }
                        if (i+2 > points.length-1) {
                            p4 = points[i+1];
                        } else {
                            p4 = points[i+2];
                        }
                        this.quadratic(p1,points[i],points[i+1],p4);
                    }
                }
                this.drawPoints();
            }

            // The background border
            this.drawBorder = function() {
                'use strict';

                this.ctx.beginPath();
                this.ctx.lineWidth = 1;
                this.ctx.strokeStyle = '#000000';
                this.ctx.rect(0,0,this.width,this.height);
                this.ctx.stroke();
            }

            // The background grid
            this.drawGrid = function() {
                'use strict';

                this.drawBorder();

                var space = this.width/4.0;

                this.ctx.beginPath();
                this.ctx.lineWidth = 1;
                this.ctx.strokeStyle = '#aaaaaa';

                for(var i=0;i<this.height-space;i+=space)
                {
                    this.ctx.moveTo(0, i+space); this.ctx.lineTo(this.height, i+space);
                }
                for(var i=0;i<this.height-space;i+=space)
                {
                    this.ctx.moveTo(i+space, 0); this.ctx.lineTo(i+space, this.height);
                }
                this.ctx.stroke();
            }

            // Main function. Calculate curve coeficients and draw the curve
            this.quadratic = function(p1,p2,p3,p4) {
                'use strict';
                
                const points = this.curve.points;
                var x0,x1,x2,x3,y0,y1,y2,y3,dx,dy;

                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 1.5;
                var slope = 0;

                x0 = p2.x;
                x3 = p3.x;

                y0 = p2.y;
                y3 = p3.y;

                dx = x3 - x0;
                dy = y3 - y0;

                x1 = ((2.0*x0)/3.0) + (x3/3.0)
                x2 = (x0/3.0) + ((2.0*x3)/3.0);


                if (this.isEqual(p1,p2) && this.isEqual(p3,p4))
                {
                  y1 = y0 + (dy / 3.0);
                  y2 = y0 + ((dy * 2.0) / 3.0);
                }
                if (this.isEqual(p1,p2) && !this.isEqual(p3,p4) )
                {

                    slope = ((p4.y) - y0) / (p4.x - x0);
                    y2 = y3 - ((slope * dx) / 3.0);
                    y1 = y0 + ((y2 - y0) / 2.0);

                }
                if (!this.isEqual(p1,p2) && this.isEqual(p3,p4) )
                {
                  slope = (y3 - (p1.y)) / (x3 - p1.x);

                  y1 = y0 + ((slope * dx) / 3.0);
                  y2 = y3 + ((y1 - y3) / 2.0);
                }

                if ( !this.isEqual(p1,p2) && !this.isEqual(p3,p4) ) {
                    slope = (y3 - (p1.y)) / (x3 - p1.x);
                    y1 = y0 + ((slope * dx) / 3.0);
                    slope = ((p4.y) - y0) / (p4.x - x0);
                    y2 = y3 - ((slope * dx) / 3.0);
                }

                this.ctx.beginPath();
                this.ctx.moveTo(x0*this.width, this.height-(y0*this.height));

                var step =(x3-x0)/20.0;
                var tx = x0;

                for(var i=0.0;i<=1.05;i+=0.05) {

                    var ty =     (y0 * Math.pow((1-i),3)) +
                        (3 * y1 * Math.pow((1-i),2) * i)     +
                        (3 * y2 * (1-i) * i     * i)     +
                        (y3 * i     * i     * i);

                    this.ctx.lineTo(tx*this.width,this.height-(ty*this.height));
                    tx = tx + step;

                }

                this.ctx.moveTo(0, this.height-(points[0].y*this.height));
                this.ctx.lineTo(points[0].x*this.width,this.height-(points[0].y*this.height));

                this.ctx.moveTo(points[points.length-1].x*this.width, this.height-(points[points.length-1].y*this.height));
                this.ctx.lineTo(this.width,this.height-(points[points.length-1].y*this.height));

                this.ctx.stroke();
                return true;
            }

            // Draw the control points
            this.drawPoints = function() {
                'use strict';

                const points = this.curve.points;
                this.ctx.fillStyle = '#ff0000';
                this.ctx.beginPath();

                for(var i=0;i<points.length;i++)
                {
                    this.ctx.moveTo(points[i].x*this.width,this.height-(points[i].y*this.height));
                    this.ctx.arc(points[i].x*this.width,this.height-(points[i].y*this.height), 3, 0 , 2 * Math.PI, false);
                }
                this.ctx.fill();
            }

            this.getCoordinateFromEvent = function(event){
                if(!event) var event = window.event;
                var canvasRect = this.c.getBoundingClientRect();
                var pointerCoordinate = {
                    x: (event.pageX-canvasRect.left)/this.width,
                    y: 1.0-((event.pageY-canvasRect.top)/this.height)
                }
                return pointerCoordinate;
            }

            this.mouseDown = function(event) {
                'use strict';
                var pointerCoordinate = this.getCoordinateFromEvent(event);
                var clickedPoint = this.curve.getClosestPointToCoordinate(pointerCoordinate, this.point_selection_threshold);

                if (clickedPoint !== -1 ){
                    this.currentPoint = clickedPoint;
                }
                else{
                    this.currentPoint = this.curve.addPoint(pointerCoordinate);
                }
            }

            this.rightClick = function(event) {
                'use strict';
                var pointerCoordinate = this.getCoordinateFromEvent(event);
                var clickedPoint = this.curve.getClosestPointToCoordinate(pointerCoordinate, this.point_selection_threshold);

                if (clickedPoint !== -1 ){
                    this.curve.removePoint(clickedPoint);
                }
            }

            this.mouseUp = function(event) {
               'use strict';
                this.currentPoint = -1;
            }

            this.mouseMove = function(event) {
                if (this.currentPoint == -1) return;
                var canvasRect = this.c.getBoundingClientRect();
                var newPosition = {
                    x: (event.pageX-canvasRect.left)/this.width,
                    y: 1.0-((event.pageY-canvasRect.top)/this.height)
                };
                this.movePoint(this.currentPoint, newPosition);
            }
            
            this.movePoint = function(index, newPosition){
               'use strict';
                var prevx,nextx;
                const points = this.curve.points;
                try{
                    if (index > 0)
                        prevx = points[index-1].x;
                    else
                        prevx = 0;
                    if (index==points.length-1)
                        nextx = 1.0;
                    else
                        nextx = points[index+1].x;

                    var canvasRect = this.c.getBoundingClientRect();
                    if(newPosition.x > prevx && newPosition.x < nextx) {
                        this.curve.movePoint(index, newPosition);
                        this.redraw = 1;
                    }
                }
                catch(e){
                }
            }
            this.draw();
        }

        // Initialize HTML objects
        const getHtmlCoordClass = function(axis){
            return `coord-input-${axis}`;
        }

        const getHtmlCoordId = function(uid, axis){
            return `coord-input-${axis}-${uid}`;
        }

        const getHtmlCoordInput = function(value, uid, axis){
            const style     = `style="width: 66px"`;
            const html_class= `class="${getHtmlCoordClass(axis)}"`;
            const id            = `id="${getHtmlCoordId(uid, axis)}"`;
            const type          = `type="number" min="0.0" max="1.0" step="0.001"`;
            const html_value   = `value="${value.toFixed(3)}"`;
            return `${axis.toUpperCase()}= <input ${id} ${html_class} ${style} ${type} ${html_value}>`;
        }

        const getHtmlForPoint = function(point){
            line = `<p>point: ${point.uid}</p>`;
            line = line += getHtmlCoordInput(point.x, point.uid, 'x');
            line = line += ' ' + getHtmlCoordInput(point.y, point.uid, 'y');
            return line;
        }

        const nodered_addItem = function(row, index, data){
            $(row).html(getHtmlForPoint(data));
            $(row).on('input', function(){
                const newLocation = {
                    x: parseFloat($(`#${getHtmlCoordId(data.uid, 'x')}`).val()),
                    y: parseFloat($(`#${getHtmlCoordId(data.uid, 'y')}`).val())
                };
                const index = curve.getPositionOfPoint(data.uid);
                curveView.movePoint(index, newLocation);
            });
            $('#node-inputer-points-container').editableList('sort');
        }

        const nodered_sort = function(itemA, itemB){
            return itemA.x - itemB.x;
        }

        const nodered_removeItem = function(point){
            console.log('removed point: ', point);
        }

        $('#node-input-points-container').editableList({
            removable: true,
            addItem: nodered_addItem,
            removeItem: nodered_removeItem,
            sort: nodered_sort
        });

        // Initialize JavaScript Objects
        const curve_onAddPoint = function(index, point){
            $('#node-input-points-container').editableList('addItem', point);
        }

        const curve_onMovePoint = function(index, point){
            console.log(`#${getHtmlCoordId(point.uid, 'x')}`);
            console.log($(`#${getHtmlCoordId(point.uid, 'x')}`).val());
            const items = $('#node-input-points-container').editableList('items');
            $(item[index]).find(getHtmlCoordClass('x')).val(point.x.toFixed(3));
            $(item[index]).find(getHtmlCoordClass('y')).val(point.y.toFixed(3));
        }

        const curve_onRemovePoint = function(index, point, originalPoint){
            $('#node-input-points-container').editableList('removeItem', originalPoint);
        }

        config = {
            points: [],
            onAddPoint: curve_onAddPoint,
            onMovePoint: curve_onMovePoint,
            onRemovePoint: curve_onRemovePoint
        };

        for(var i=0;i < this.points.length;i++){
            const point_raw = this.points[i];
            config.points.push({x: parseFloat(point_raw.x), y: parseFloat(point_raw.y)});
        }

        const canvas = document.getElementById('curve-canvas');
        const curve = new Curve(config);
        const curveView = new CurveView(canvas, curve);
    },
    oneditsave: function(){
        var points = $('#node-input-points-container').editableList('items');
        var node = this;
        node.points = [];
        points.each(function(i){
            const x = parseFloat($(this).find('.coord-input-x').val());
            const y = parseFloat($(this).find('.coord-input-y').val());
            node.points.push({x: x, y: y});
        });
    }
});
</script>

<script type="text/x-red" data-template-name="userdefined-curve">
    <canvas id="curve-canvas" height="256" width="256"></canvas>
    <div class="form-row node-input-points-container-row">
        <ol id="node-input-points-container"></ol>
    </div>
</script>

<script type="text/x-red" data-help-name="userdefined-curve">
    <p>A simple node</p>

</script>
